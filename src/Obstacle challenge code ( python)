#!/usr/bin/env python3
# -- coding: utf-8 --

import cv2 as cv
import numpy as np
import yaml, glob, time, os, re, math, sys
from collections import deque

try:
    import serial
except Exception:
    serial = None

# ==========================================================
# =================== TUNING PANEL =========================
# ==========================================================
TUNE = {
    # --- Corridor turns (BLUE/ORANGE) ---
    "TURN_DEG": float(os.environ.get("TURN_DEG", "90.0")),
    "TURN_TOL_DEG": float(os.environ.get("TURN_TOL_DEG", "10.0")),

    # --- Pillar sidestep turns (RED/GREEN) ---
    "PILLAR_TURN_DEG": float(os.environ.get("PILLAR_TURN_DEG", "90.0")),
    "PILLAR_TURN_TOL_DEG": float(os.environ.get("PILLAR_TURN_TOL_DEG", "10.0")),

    # --- Flip (first pillar after 7th corner) ---
    "FLIP_TURN_DEG": float(os.environ.get("FLIP_TURN_DEG", "180.0")),     # ~180; tune if needed
    "FLIP_FWD_HOLD_S": float(os.environ.get("FLIP_FWD_HOLD_S", "1.50")),   # forward-centering hold before flip
    "FLIP_LEFT_SIGN": float(os.environ.get("FLIP_LEFT_SIGN", "1.0")),      # +1: LEFT = +angle; use -1 if your yaw is opposite

    # --- Turn watchdogs (safety net only) ---
    "CORNER_TURN_MAX_S": float(os.environ.get("CORNER_TURN_MAX_S", "2.3")),
    "PILLAR_TURN_MAX_S": float(os.environ.get("PILLAR_TURN_MAX_S", "2.0")),

    # --- Run cap ---
    "MAX_TURNS": int(os.environ.get("MAX_TURNS", "12")),

    # --- Servo geometry (deg) ---
    # center=90, LEFT=120, RIGHT=65 (forward)
    "CENTER_DEG": int(os.environ.get("CENTER_DEG", "90")),
    "LEFT_LIMIT": int(os.environ.get("LEFT_LIMIT", "65")),     # numeric min (right-most)
    "RIGHT_LIMIT": int(os.environ.get("RIGHT_LIMIT", "120")),  # numeric max (left-most)

    # --- General speeds (PWM 0..255) ---
    "DRIVE_SPEED": int(os.environ.get("DRIVE_SPEED", "26")),
    "SEE_COLOR_SPEED": int(os.environ.get("SEE_COLOR_SPEED", "22")),
    "TURN_SPEED": int(os.environ.get("TURN_SPEED", "28")),

    # --- Pillar pass speeds ---
    "PILLAR_TURN_SPEED": int(os.environ.get("PILLAR_TURN_SPEED", "25")),
    "PILLAR_FWD_SPEED": int(os.environ.get("PILLAR_FWD_SPEED", "26")),
    "PILLAR_BACK_SPEED": int(os.environ.get("PILLAR_BACK_SPEED", "26")),

    # --- Corner (BLUE/ORANGE) backward-turn fixed servo angles ---
    "BACK_LEFT_SERVO_DEG": int(os.environ.get("BACK_LEFT_SERVO_DEG", "65")),    # BLUE -> left while reversing
    "BACK_RIGHT_SERVO_DEG": int(os.environ.get("BACK_RIGHT_SERVO_DEG", "120")), # ORANGE -> right while reversing

    # --- Distances (cm) ---
    "FRONT_TURN_CM": float(os.environ.get("FRONT_TURN_CM", "25.0")),
    "BACK_STOP_CM": float(os.environ.get("BACK_STOP_CM", "30.0")),
    "PILLAR_ACCEPT_CM": float(os.environ.get("PILLAR_ACCEPT_CM", "50.0")),
    "PILLAR_APPROACH_FRONT_CM": float(os.environ.get("PILLAR_APPROACH_FRONT_CM", "6.0")),
    "PILLAR_BACK_TO_FRONT_CM": float(os.environ.get("PILLAR_BACK_TO_FRONT_CM", "13.0")),

    # --- Color detection / ROI (BLUE/ORANGE lines) ---
    "COLOR_CONFIRM_FRAMES": int(os.environ.get("COLOR_CONFIRM_FRAMES", "2")),
    "MIN_PIX_COLOR": int(os.environ.get("MIN_PIX_COLOR", "50")),
    "BLUR_KSIZE": int(os.environ.get("BLUR_KSIZE", "3")),
    "COLOR_ROI_WIDTH_FRAC": float(os.environ.get("COLOR_ROI_WIDTH_FRAC", "0.28")),
    "COLOR_ROI_HEIGHT_FRAC": float(os.environ.get("COLOR_ROI_HEIGHT_FRAC", "0.20")),
    "ROI_SCALE_AFTER_FIRST_TURN": float(os.environ.get("ROI_SCALE_AFTER_FIRST_TURN", "1.3")),
    "SAT_BOOST": float(os.environ.get("SAT_BOOST", "1.10")),
    "COLOR_SUSPEND_SEC": float(os.environ.get("COLOR_SUSPEND_SEC", "4.0")),

    # --- Pillar detection (RED/GREEN) ---
    "PILLAR_CONFIRM_FRAMES": int(os.environ.get("PILLAR_CONFIRM_FRAMES", "2")),
    "PILLAR_MIN_PIX": int(os.environ.get("PILLAR_MIN_PIX", "80")),
    "PILLAR_ROI_WIDTH_FRAC": float(os.environ.get("PILLAR_ROI_WIDTH_FRAC", "0.60")),
    "PILLAR_ROI_HEIGHT_FRAC": float(os.environ.get("PILLAR_ROI_HEIGHT_FRAC", "0.55")),
    "PILLAR_DIST_K": float(os.environ.get("PILLAR_DIST_K", "4000.0")),

    # --- Pillar gates (full-frame) ---
    "RED_LINE_X_FRAC": float(os.environ.get("RED_LINE_X_FRAC", "0.150")),
    "GREEN_LINE_X_FRAC": float(os.environ.get("GREEN_LINE_X_FRAC", "0.850")),

    # --- Yaw centering ---
    "STEER_SIGN": float(os.environ.get("STEER_SIGN", "1.0")),              # if steering flips after flip, set -1
    "STEER_KP_DEG_PER_DEG": float(os.environ.get("STEER_KP_DEG_PER_DEG", ".835")),
    "STEER_MAX_DEG": float(os.environ.get("STEER_MAX_DEG", "8.0")),
    "STEER_DEAD_ERR_DEG": float(os.environ.get("STEER_DEAD_ERR_DEG", "0.01")),
    "ERR_FILTER_ALPHA": float(os.environ.get("ERR_FILTER_ALPHA", "0.75")),
    "STEER_SLEW_DEG": int(os.environ.get("STEER_SLEW_DEG", "20")),
    "CENTER_STEER_MIN": 65, "CENTER_STEER_MAX": 105,

    # --- Post-flip centering softener (helps stabilize after ±180) ---
    "POST_FLIP_KP_GAIN": float(os.environ.get("POST_FLIP_KP_GAIN", "0.95")),  # scales STEER_KP for a short time
    "POST_FLIP_MAX_DEG": float(os.environ.get("POST_FLIP_MAX_DEG", "8.0")),   # caps steering during soft phase
    "POST_FLIP_KP_HOLD_S": float(os.environ.get("POST_FLIP_KP_HOLD_S", "1.5")),

    # --- Wall slowdowns ---
    "WALL_SLOW_SIDE_ON_CM": float(os.environ.get("WALL_SLOW_SIDE_ON_CM", "7.5")),
    "WALL_SLOW_SIDE_OFF_CM": float(os.environ.get("WALL_SLOW_SIDE_OFF_CM", "8.5")),
    "SIDE_SLOWDOWN_FACTOR": float(os.environ.get("SIDE_SLOWDOWN_FACTOR", "0.55")),
    "WALL_SLOW_FRONT_ON_CM": float(os.environ.get("WALL_SLOW_FRONT_ON_CM", "45.0")),
    "FRONT_SLOWDOWN_FACTOR": float(os.environ.get("FRONT_SLOWDOWN_FACTOR", "0.55")),
    "WALL_SLOW_MIN_SPEED": int(os.environ.get("WALL_SLOW_MIN_SPEED", "21")),

    # --- Wall avoid ---
    "WALL_AVOID_ON_CM": float(os.environ.get("WALL_AVOID_ON_CM", "7.5")),
    "WALL_AVOID_OFF_CM": float(os.environ.get("WALL_AVOID_OFF_CM", "8.5")),
    "WALL_AVOID_HOLD_S": float(os.environ.get("WALL_AVOID_HOLD_S", "0.35")),
    "WALL_AVOID_KP_DEG_PER_CM": float(os.environ.get("WALL_AVOID_KP_DEG_PER_CM", "1.8")),
    "WALL_AVOID_EXP": float(os.environ.get("WALL_AVOID_EXP", "1.0")),
    "WALL_AVOID_MIN_DEG": float(os.environ.get("WALL_AVOID_MIN_DEG", "2.0")),
    "WALL_AVOID_MAX_BIAS_DEG": float(os.environ.get("WALL_AVOID_MAX_BIAS_DEG", "16.0")),
    "WALL_AVOID_GAIN": float(os.environ.get("WALL_AVOID_GAIN", "1.0")),
    "AVOID_INVERT_DIR": int(os.environ.get("AVOID_INVERT_DIR", "1")),   # keep your rig’s inversion
    "WALL_AVOID_SPEED": int(os.environ.get("WALL_AVOID_SPEED", "24")),

    # --- Camera / serial ---
    "ALLOW_NO_CAMERA": int(os.environ.get("ALLOW_NO_CAMERA", "0")),
    "FRAME_W": int(os.environ.get("FRAME_W", "640")),
    "FRAME_H": int(os.environ.get("FRAME_H", "480")),
    "ROBOT_PORT": os.environ.get("ROBOT_PORT", "/dev/ttyUSB0"),
    "ROBOT_BAUD": int(os.environ.get("ROBOT_BAUD", "115200")),

    # --- Link watchdogs ---
    "STALE_TLM_SEC": float(os.environ.get("STALE_TLM_SEC", "1.2")),
    "STALE_LINK_SEC": float(os.environ.get("STALE_LINK_SEC", "2.5")),
    "PING_PERIOD_SEC": float(os.environ.get("PING_PERIOD_SEC", "0.7")),
    "RESET_BACKOFF_SEC": float(os.environ.get("RESET_BACKOFF_SEC", "4.0")),

    # --- Misc ---
    "US_MAX_CM": float(os.environ.get("US_MAX_CM", "300.0")),
}

# ================ CONSTANTS / HELPERS ================
MIN_SPEED   = 0
CENTER_DEG  = TUNE["CENTER_DEG"]
LEFT_LIMIT  = TUNE["LEFT_LIMIT"]
RIGHT_LIMIT = TUNE["RIGHT_LIMIT"]
SPAN_LEFT   = abs(CENTER_DEG - LEFT_LIMIT)
SPAN_RIGHT  = abs(RIGHT_LIMIT - CENTER_DEG)

def gstreamer_pipeline(sensor_id=0, capture_width=1280, capture_height=720,
                       display_width=640, display_height=480, framerate=30, flip_method=0):
    return (f"nvarguscamerasrc sensor-id={sensor_id} ! "
            f"video/x-raw(memory:NVMM), width={capture_width}, height={capture_height}, "
            f"format=(string)NV12, framerate={framerate}/1 ! "
            f"nvvidconv flip-method={flip_method} ! "
            f"video/x-raw, width={display_width}, height={display_height}, format=(string)BGRx ! "
            "videoconvert ! video/x-raw, format=(string)BGR ! appsink drop=1")

def open_camera():
    w, h = TUNE["FRAME_W"], TUNE["FRAME_H"]
    cap = None
    try:
        cap = cv.VideoCapture(gstreamer_pipeline(display_width=w, display_height=h), cv.CAP_GSTREAMER)
    except Exception:
        cap = None
    if not (cap and cap.isOpened()):
        try: cap = cv.VideoCapture(0, cv.CAP_V4L2)
        except Exception: cap = None
    if cap and cap.isOpened(): return cap, False
    if TUNE["ALLOW_NO_CAMERA"]:
        print("WARNING: camera open failed; using dummy frames.")
        class DummyCap:
            def isOpened(self): return True
            def read(self):
                frame = np.zeros((h, w, 3), dtype=np.uint8)
                cv.putText(frame, "NO CAMERA", (10,30),
                           cv.FONT_HERSHEY_SIMPLEX, 0.9, (0,0,255), 2)
                return True, frame
            def release(self): pass
        return DummyCap(), True
    print("ERROR: camera open failed."); return None, False

def load_latest_yaml():
    override = os.environ.get("VISION_CFG", "").strip()
    if override and os.path.isfile(override): path = override
    else:
        cands = sorted(glob.glob("config/vision_*.yaml"))
        if not cands: raise FileNotFoundError("No config in ./config — need RED/GREEN/BLUE/ORANGE ranges.")
        path = cands[-1]
    with open(path, "r") as f: return yaml.safe_load(f), path

def wrap180(a):
    while a>180: a-=360
    while a<-180: a+=360
    return a

def shortest_err(target_deg, now_deg): return wrap180(target_deg - now_deg)

def deg_to_norm(angle_deg):
    angle_deg = float(max(LEFT_LIMIT, min(RIGHT_LIMIT, angle_deg)))
    if angle_deg >= CENTER_DEG:
        return (angle_deg - CENTER_DEG) / float(max(1.0, SPAN_RIGHT))
    else:
        return (angle_deg - CENTER_DEG) / float(max(1.0, SPAN_LEFT))

def slew_limit(prev, target, max_delta):
    if prev is None: return target
    if target > prev + max_delta: return prev + max_delta
    if target < prev - max_delta: return prev - max_delta
    return target

def mask_hsv_ranges(hsv, ranges):
    if isinstance(ranges, dict) and "low" in ranges and "high" in ranges:
        low, high = np.array(ranges["low"], np.uint8), np.array(ranges["high"], np.uint8)
        return cv.inRange(hsv, low, high)
    mask = None
    for r in (ranges if isinstance(ranges, list) else []):
        if "low" in r and "high" in r:
            m = cv.inRange(hsv, np.array(r["low"], np.uint8), np.array(r["high"], np.uint8))
            mask = m if mask is None else cv.bitwise_or(mask, m)
    if mask is None: mask = np.zeros(hsv.shape[:2], dtype=np.uint8)
    return mask

# =================== MAIN ===================
def main():
    cfg, cfg_path = load_latest_yaml()
    print("Loaded vision config:", cfg_path)

    # ---- Serial ----
    ser = None; device = TUNE["ROBOT_PORT"]; baud = TUNE["ROBOT_BAUD"]
    last_tlm_t = 0.0; last_pong_t = 0.0; last_ping_t = 0.0; last_reset_t = -1e9
    rx_buf = b""
    tlm_re = re.compile(
        r"^TLM,.*yaw=([\-0-9\.]+),state=([0-9]),steer=([\-0-9\.]+),speed=([0-9]+),dF=([\-0-9]+),dL=([\-0-9]+),dR=([\-0-9]+),dB=([\-0-9]+)"
    )

    def open_serial():
        nonlocal ser
        if serial is None: return
        try:
            ser = serial.Serial(device, baudrate=baud, timeout=0.01, write_timeout=0.2, dsrdtr=False)
            time.sleep(0.30)
            ser.reset_input_buffer(); ser.reset_output_buffer()
            print("Serial OK on", device)
        except Exception as e:
            print("WARNING: serial not open ->", e); ser = None

    def safe_write(line_bytes):
        nonlocal ser
        if serial is None: return False
        if ser is None:
            open_serial()
            if ser is None: return False
        try:
            ser.write(line_bytes); return True
        except Exception as e:
            print("Serial write error:", e)
            try: ser.close()
            except Exception: pass
            ser=None
            open_serial()
            if ser:
                try: ser.write(line_bytes); return True
                except Exception as e2: print("Write retry failed:", e2)
        return False

    def reset_arduino():
        nonlocal ser, last_reset_t
        now = time.time()
        if now - last_reset_t < TUNE["RESET_BACKOFF_SEC"]: return
        last_reset_t = now
        try:
            if ser and ser.is_open: ser.close()
        except Exception: pass
        time.sleep(0.2)
        open_serial()
        print("[RESET] (basic reopen)")

    def link_alive(now): return (now - max(last_tlm_t, last_pong_t)) < TUNE["STALE_LINK_SEC"]

    def maybe_ping(now):
        nonlocal last_ping_t
        if (now - last_ping_t) >= TUNE["PING_PERIOD_SEC"]:
            safe_write(b"PING\n")
            last_ping_t = now

    # --- Telemetry ---
    last_yaw = 0.0
    last_US = {"dF":-1, "dL":-1, "dR":-1, "dB":-1}
    us_ema = {"dF":-1.0, "dL":-1.0, "dR":-1.0, "dB":-1.0}
    arduino_armed = False

    def sane_cm(x):
        if x is None or x < 0: return -1
        return float(min(x, TUNE["US_MAX_CM"]))

    def read_tlm():
        nonlocal rx_buf, last_yaw, last_tlm_t, last_US, us_ema, last_pong_t, arduino_armed, ser
        if ser is None: return
        try:
            data = ser.read(256)
            if not data: return
            rx_buf += data
            while b"\n" in rx_buf:
                line, rx_buf = rx_buf.split(b"\n", 1)
                s = line.decode("utf-8", "ignore").strip()
                if s == "PONG": last_pong_t = time.time(); continue
                if s == "READY": last_pong_t = time.time(); continue
                if s == "ARMED": arduino_armed = True; last_pong_t = time.time(); continue
                m = tlm_re.match(s)
                if m:
                    last_yaw = float(m.group(1)); last_tlm_t = time.time()
                    vals = [int(m.group(i)) for i in (5,6,7,8)]
                    for (k, v) in zip(("dF","dL","dR","dB"), vals):
                        v = float(v)
                        a = 0.35
                        if v < 0: last_US[k] = -1
                        else:
                            if us_ema[k] < 0: us_ema[k] = v
                            else: us_ema[k] = (1-a)*us_ema[k] + a*v
                            last_US[k] = int(us_ema[k])
        except Exception as e:
            print("Serial read error:", e)
            try: ser.close()
            except Exception: pass
            open_serial()

    # ---- Camera ----
    cap, using_dummy = open_camera()
    if cap is None: return

    # ============= State & corridor model =============
    STATE_WAIT_START, STATE_RUN, STATE_CORNER_TURNING, STATE_CORNER_BACKCENTER, STATE_FLIP_WAIT, STATE_FLIP_TURN, STATE_DONE = range(7)
    state = STATE_WAIT_START

    start_yaw = 0.0
    corridor_idx = 0
    orientation_offset_deg = 0.0

    yaw_ref = 0.0
    def set_ref_to_corridor():
        nonlocal yaw_ref
        yaw_ref = wrap180(start_yaw + corridor_idx * TUNE["TURN_DEG"] + orientation_offset_deg)

    # Corner book-keeping
    yaw_at_corner_start = None
    intended_corner_yaw = None
    corner_turn_start_t = -1.0
    turn_count = 0
    target_idx = 0

    # NEW: latch the global corner direction from the first corner we see.
    # +1 => RIGHT (CW), -1 => LEFT (CCW)
    corner_dir_latch = None

    # Inversion + flip scheduling
    invert_last4 = False
    waiting_first_pillar_after_turn7 = False

    # Flip micro-FSM
    flip_scheduled_color = None  # RED/GREEN of the first pillar after 7th corner
    flip_wait_until = -1.0
    rotate_target = None
    rotate_start_t = -1.0
    post_flip_soft_until = -1.0   # for gentle centering immediately after flip

    # Corner detection control
    detect_enabled = True
    color_pause_until = -1.0
    color_q = deque(maxlen=TUNE["COLOR_CONFIRM_FRAMES"])
    see_color_slow = False
    corner_color = None

    # Pillar detection control
    pillar_q = deque(maxlen=TUNE["PILLAR_CONFIRM_FRAMES"])
    pillar_active = False
    pillar_color = None
    pillar_state = "IDLE" # IDLE, TURN, FWD, BACK, RETURN
    pillar_turn_target = None
    pillar_turn_start_t = -1.0
    corridor_yaw_before_pillar = None

    # Pillar memory / recording
    first_pillar_after_turn = {1:None, 2:None, 3:None, 4:None}
    need_record_after_turn = False
    last_pillar_before_turn4 = None

    # Steering control
    err_ema = 0.0
    last_steer_cmd = None
    last_tx = 0.0

    # Wall avoid FSM
    avoid_active = False
    avoid_side = None
    avoid_until = -1.0

    # HUD window
    cv.namedWindow("robot", cv.WINDOW_AUTOSIZE)

    # --- helpers to send ---
    def send_center_abs_deg(steer_deg, speed_pwm):
        steer_deg = int(max(LEFT_LIMIT, min(RIGHT_LIMIT, int(steer_deg))))
        steer_norm = deg_to_norm(steer_deg)
        spd = max(MIN_SPEED, min(255, int(speed_pwm)))
        safe_write(f"CENTER,{steer_norm:.3f},{spd}\n".encode("ascii"))

    def send_center_deg(steer_deg, speed_pwm):
        send_center_abs_deg(steer_deg, speed_pwm)

    def send_back(speed_pwm):
        spd = max(0, min(255, int(speed_pwm)))
