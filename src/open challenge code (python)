#!/usr/bin/env python3
# -- coding: utf-8 --
"""
Jetson side — starts on S key OR when Arduino push button arms (prints 'ARMED').

Hotkeys:
  S -> send START (manual start)
  X -> reset Arduino (with backoff)
  Q -> STOP and quit
"""

import cv2 as cv
import numpy as np
import yaml, glob, time, os, re, math, sys
from collections import deque

try:
    import serial
except Exception:
    serial = None

# ==========================================================
# =================== TUNING PANEL =========================
# ==========================================================
TUNE = {
    # --- Turn / geometry ---
    "TURN_DEG": float(os.environ.get("TURN_DEG", "85.0")),
    "TURN_TRIGGER_TOL_DEG": float(os.environ.get("TURN_TRIGGER_TOL_DEG", "80.0")),
    "CENTER_TURN_STEP_DEG": float(os.environ.get("CENTER_TURN_STEP_DEG", "90.0")),

    # --- Run & stop caps ---
    "MAX_TURNS": int(os.environ.get("MAX_TURNS", "12")),
    "STOP_AT_END_CM": float(os.environ.get("STOP_AT_END_CM", "140.0")),

    # --- Steering servo geometry (absolute degrees) ---
    # Reversed-install servo: center=90, left=110, right=60
    "CENTER_DEG": int(os.environ.get("CENTER_DEG", "90")),
    "LEFT_LIMIT": int(os.environ.get("LEFT_LIMIT", "60")),
    "RIGHT_LIMIT": int(os.environ.get("RIGHT_LIMIT", "110")),
    # flip world->servo sign cleanly (1=reversed)
    "SERVO_REVERSED": int(os.environ.get("SERVO_REVERSED", "1")),

    # --- Drive speeds (PWM 0..255) ---
    "DRIVE_SPEED": int(os.environ.get("DRIVE_SPEED", "43")),
    "TURN_SPEED": int(os.environ.get("TURN_SPEED", "27")),
    "POST_TURN_SPEED": int(os.environ.get("POST_TURN_SPEED", "25")),
    "POST_TURN_SEC": float(os.environ.get("POST_TURN_SEC", "1.5")),
    "SEE_COLOR_SPEED": int(os.environ.get("SEE_COLOR_SPEED", "27")),
    "MIN_SPEED": int(os.environ.get("MIN_SPEED", "0")),

    # --- Wall proximity slowdowns (speed management) ---
    "WALL_SLOW_SIDE_ON_CM": float(os.environ.get("WALL_SLOW_SIDE_ON_CM", "8.0")),
    "WALL_SLOW_SIDE_OFF_CM": float(os.environ.get("WALL_SLOW_SIDE_OFF_CM", "9.0")),
    "SIDE_SLOWDOWN_FACTOR": float(os.environ.get("SIDE_SLOWDOWN_FACTOR", "0.55")),
    "WALL_SLOW_FRONT_ON_CM": float(os.environ.get("WALL_SLOW_FRONT_ON_CM", "45.0")),
    "FRONT_SLOWDOWN_FACTOR": float(os.environ.get("FRONT_SLOWDOWN_FACTOR", "0.550")),
    "WALL_SLOW_MIN_SPEED": int(os.environ.get("WALL_SLOW_MIN_SPEED", "21")),

    # --- Wall-safety steering authority (small push away near walls) ---
    "WALL_STEER_GAIN": float(os.environ.get("WALL_STEER_GAIN", ".3")),
    "WALL_STEER_MAX_ADD_DEG": float(os.environ.get("WALL_STEER_MAX_ADD_DEG", "0.80")),
    "WALL_STEER_EXPAND_CENTER_CLAMP": int(os.environ.get("WALL_STEER_EXPAND_CENTER_CLAMP", "1")),
    "WALL_STEER_CENTER_MIN": int(os.environ.get("WALL_STEER_CENTER_MIN", "80")),
    "WALL_STEER_CENTER_MAX": int(os.environ.get("WALL_STEER_CENTER_MAX", "100")),

    # --- Strong Wall AVOID (independent of slowdown) ---
    "WALL_AVOID_ON_CM": float(os.environ.get("WALL_AVOID_ON_CM", "11.5")),
    "WALL_AVOID_OFF_CM": float(os.environ.get("WALL_AVOID_OFF_CM", "12.5")),
    "WALL_AVOID_MAX_BIAS_DEG": float(os.environ.get("WALL_AVOID_MAX_BIAS_DEG", "25.0")),
    "WALL_AVOID_GAIN": float(os.environ.get("WALL_AVOID_GAIN", "0.65")),
    "WALL_AVOID_SPEED": int(os.environ.get("WALL_AVOID_SPEED", "24")),
    "WALL_AVOID_TIMEOUT_S": float(os.environ.get("WALL_AVOID_TIMEOUT_S", "1.2")),

    # --- Contact failsafe (very close or sensors blind) ---
    "CONTACT_ON_CM": float(os.environ.get("CONTACT_ON_CM", "12.0")),
    "CONTACT_TREAT_INVALID_AS_ON": int(os.environ.get("CONTACT_TREAT_INVALID_AS_ON", "1")),
    "CONTACT_STEER_DEG": float(os.environ.get("CONTACT_STEER_DEG", "14.0")),
    "CONTACT_HOLD_S": float(os.environ.get("CONTACT_HOLD_S", "0.3")),
    "CONTACT_SPEED_FACTOR": float(os.environ.get("CONTACT_SPEED_FACTOR", "0.6")),

    # --- Turn gating (FRONT + SIDE) ---
    "FRONT_TURN_THRESH_CM": float(os.environ.get("FRONT_TURN_THRESH_CM", "35.0")),
    "TURN_USE_SIDE_GATE": int(os.environ.get("TURN_USE_SIDE_GATE", "1")),
    "TURN_SIDE_OPEN_CM": float(os.environ.get("TURN_SIDE_OPEN_CM", "120.0")),
    "TURN_SIDE_LOGIC": os.environ.get("TURN_SIDE_LOGIC", "OR").upper(),
    "TURN_GATE_COMBINE": os.environ.get("TURN_GATE_COMBINE", "OR").upper(),

    # --- Color detection / ROI (BLUE/ORANGE) ---
    "COLOR_CONFIRM_FRAMES": int(os.environ.get("COLOR_CONFIRM_FRAMES", "1")),
    "DETECT_COOLDOWN_S": float(os.environ.get("DETECT_COOLDOWN_S", "2.5")),
    "MIN_PIX_COLOR": int(os.environ.get("MIN_PIX_COLOR", "1")),
    "COLOR_ERODE_IT": int(os.environ.get("COLOR_ERODE_IT", "0")),
    "COLOR_DILATE_IT": int(os.environ.get("COLOR_DILATE_IT", "1")),
    "COLOR_ROI_WIDTH_FRAC": float(os.environ.get("COLOR_ROI_WIDTH_FRAC", "0.25")),
    "COLOR_ROI_HEIGHT_FRAC": float(os.environ.get("COLOR_ROI_HEIGHT_FRAC", "0.20")),
    "ROI_SCALE_AFTER_FIRST_TURN": float(os.environ.get("ROI_SCALE_AFTER_FIRST_TURN", "1.3")),
    "COLOR_ROI_AFTER_TURNS": int(os.environ.get("COLOR_ROI_AFTER_TURNS", "0")),
    "COLOR_PICK_MODE": "maxpix",
    "COLOR_TURN_MAP": {"BLUE": "LEFT", "ORANGE": "RIGHT"},
    "SAT_BOOST": float(os.environ.get("SAT_BOOST", "1.15")),
    "BLUR_KSIZE": int(os.environ.get("BLUR_KSIZE", "3")),
    "COLOR_SUSPEND_SEC": float(os.environ.get("COLOR_SUSPEND_SEC", "2.5")),

    # --- Color re-arm (prepare for next junction) ---
    "COLOR_REARM_FRONT_CM": float(os.environ.get("COLOR_REARM_FRONT_CM", "80.0")),
    "COLOR_REARM_DELAY_S": float(os.environ.get("COLOR_REARM_DELAY_S", "0.6")),
    "DISABLE_DETECT_DURING_TURN": True,

    # --- Yaw centering controller ---
    "STEER_KP_DEG_PER_DEG": float(os.environ.get("STEER_KP_DEG_PER_DEG", "8.90")),
    "STEER_EXP": float(os.environ.get("STEER_EXP", "1.0")),
    "STEER_DEAD_ERR_DEG": float(os.environ.get("STEER_DEAD_ERR_DEG", "0.02")),
    "STEER_OUT_DB_DEG": float(os.environ.get("STEER_OUT_DB_DEG", ".2")),
    "STEER_MAX_DEG": float(os.environ.get("STEER_MAX_DEG", "5.0")),
    "ERR_FILTER_ALPHA": float(os.environ.get("ERR_FILTER_ALPHA", "1.75")),
    "STEER_SLEW_DEG": int(os.environ.get("STEER_SLEW_DEG", "20")),
    "CENTER_STEER_MIN": 70,
    "CENTER_STEER_MAX": 110,

    # --- Ultrasonic averaging & repel ---
    "US_MAX_CM": float(os.environ.get("US_MAX_CM", "300.0")),   # CHANGED (was 200.0)
    "US_EMA_ALPHA": float(os.environ.get("US_EMA_ALPHA", "0.35")),
    "US_REPEL_ON_CM": float(os.environ.get("US_REPEL_ON_CM", "18.0")),
    "US_REPEL_OFF_CM": float(os.environ.get("US_REPEL_OFF_CM", "22.0")),
    "US_REPEL_K": float(os.environ.get("US_REPEL_K", "0.06")),
    "US_REPEL_STEER_BOOST_DEG": float(os.environ.get("US_REPEL_STEER_BOOST_DEG", "6.0")),
    "US_REPEL_EXPAND_CENTER_CLAMP": int(os.environ.get("US_REPEL_EXPND_CENTER_CLAMP", "1")),
    "US_REPEL_CENTER_MIN": int(os.environ.get("US_REPEL_CENTER_MIN", "80")),
    "US_REPEL_CENTER_MAX": int(os.environ.get("US_REPEL_CENTER_MAX", "100")),

    # --- Camera ---
    "ALLOW_NO_CAMERA": int(os.environ.get("ALLOW_NO_CAMERA", "1")),
    "CAMERA_BACKEND": os.environ.get("CAMERA_BACKEND", "AUTO").upper(),
    "FRAME_W": int(os.environ.get("FRAME_W", "640")),
    "FRAME_H": int(os.environ.get("FRAME_H", "480")),

    # --- Final-run logic ---
    "FINAL_BURST_S": float(os.environ.get("FINAL_BURST_S", "1.0")),
    "FINAL_US_DELAY_S": float(os.environ.get("FINAL_US_DELAY_S", ".9")),
    "REVERSE_SUPPORTED": int(os.environ.get("REVERSE_SUPPORTED", "0")),
    "REVERSE_SPEED": int(os.environ.get("REVERSE_SPEED", "30")),
    "REVERSE_MAX_S": float(os.environ.get("REVERSE_MAX_S", "2.0")),

    # --- Serial link & watchdog ---
    "ROBOT_PORT": os.environ.get("ROBOT_PORT", "/dev/ttyUSB0"),
    "ROBOT_BAUD": int(os.environ.get("ROBOT_BAUD", "115200")),
    "STALE_TLM_SEC": float(os.environ.get("STALE_TLM_SEC", "1.2")),
    "STALE_LINK_SEC": float(os.environ.get("STALE_LINK_SEC", "2.5")),
    "PING_PERIOD_SEC": float(os.environ.get("PING_PERIOD_SEC", "0.7")),
    "RESET_BACKOFF_SEC": float(os.environ.get("RESET_BACKOFF_SEC", "4.0")),

    "ARD_RESET_METHOD": os.environ.get("ARD_RESET_METHOD", "AUTO").upper(),
    "ARD_RESET_TOUCH_DELAY_S": float(os.environ.get("ARD_RESET_TOUCH_DELAY_S", "0.8")),
    "ARD_RESET_DTR_PULSE_S": float(os.environ.get("ARD_RESET_DTR_PULSE_S", "0.12")),
}

# ================ CONSTANTS / HELPERS ================
MIN_SPEED   = TUNE["MIN_SPEED"]
CENTER_DEG  = TUNE["CENTER_DEG"]
LEFT_LIMIT  = TUNE["LEFT_LIMIT"]
RIGHT_LIMIT = TUNE["RIGHT_LIMIT"]
SPAN_LEFT   = abs(CENTER_DEG - LEFT_LIMIT)
SPAN_RIGHT  = abs(RIGHT_LIMIT - CENTER_DEG)
SERVO_DIR   = -1 if int(TUNE.get("SERVO_REVERSED", 1)) else +1

def gstreamer_pipeline(sensor_id=0, capture_width=1280, capture_height=720,
                       display_width=640, display_height=480, framerate=30, flip_method=0):
    return (f"nvarguscamerasrc sensor-id={sensor_id} ! "
            f"video/x-raw(memory:NVMM), width={capture_width}, height={capture_height}, "
            f"format=(string)NV12, framerate={framerate}/1 ! "
            f"nvvidconv flip-method={flip_method} ! "
            f"video/x-raw, width={display_width}, height={display_height}, format=(string)BGRx ! "
            "videoconvert ! video/x-raw, format=(string)BGR ! appsink drop=1")

def open_camera():
    back = TUNE["CAMERA_BACKEND"]; w, h = TUNE["FRAME_W"], TUNE["FRAME_H"]
    cap = None
    def make_gst():
        try: return cv.VideoCapture(gstreamer_pipeline(display_width=w, display_height=h), cv.CAP_GSTREAMER)
        except Exception: return None
    def make_v4l2():
        try: return cv.VideoCapture(0, cv.CAP_V4L2)
        except Exception: return None
    if back == "GST": cap = make_gst()
    elif back == "V4L2": cap = make_v4l2()
    else:
        cap = make_gst()
        if not (cap and cap.isOpened()): cap = make_v4l2()
    if cap and cap.isOpened(): return cap, False
    if TUNE["ALLOW_NO_CAMERA"]:
        print("WARNING: camera open failed; using dummy frames.")
        class DummyCap:
            def isOpened(self): return True
            def read(self):
                frame = np.zeros((h, w, 3), dtype=np.uint8)
                cv.putText(frame, "NO CAMERA (dummy)", (10,30),
                           cv.FONT_HERSHEY_SIMPLEX, 0.8, (0,0,255), 2)
                return True, frame
            def release(self): pass
        return DummyCap(), True
    print("ERROR: camera open failed."); return None, False

def load_latest_yaml():
    override = os.environ.get("VISION_CFG", "").strip()
    if override and os.path.isfile(override): path = override
    else:
        cands = sorted(glob.glob("config/vision_*.yaml"))
        if not cands: raise FileNotFoundError("No config in ./config — run tuner_multi.py and press S to save.")
        path = cands[-1]
    with open(path, "r") as f: return yaml.safe_load(f), path

def wrap180(a):
    while a>180: a-=360
    while a<-180: a+=360
    return a

def shortest_err(target_deg, now_deg): return wrap180(target_deg - now_deg)

def deg_to_norm(angle_deg):
    # Inverse of Arduino's setSteerNorm() mapping
    angle_deg = float(max(LEFT_LIMIT, min(RIGHT_LIMIT, angle_deg)))
    if angle_deg >= CENTER_DEG:
        return (angle_deg - CENTER_DEG) / float(max(1.0, SPAN_RIGHT))
    else:
        return (angle_deg - CENTER_DEG) / float(max(1.0, SPAN_LEFT))

def slew_limit(prev, target, max_delta):
    if prev is None: return target
    if target > prev + max_delta: return prev + max_delta
    if target < prev - max_delta: return prev - max_delta
    return target

def mask_hsv_single(hsv, low, high, ek=0, dk=0):
    m = cv.inRange(hsv, np.array(low, np.uint8), np.array(high, np.uint8))
    if ek > 0: m = cv.erode(m, cv.getStructuringElement(cv.MORPH_ELLIPSE, (ek, ek)))
    if dk > 0: m = cv.dilate(m, cv.getStructuringElement(cv.MORPH_ELLIPSE, (dk, dk)))
    return m

def mask_hsv_multi(hsv, ranges, ek=0, dk=0):
    if isinstance(ranges, dict) and "low" in ranges and "high" in ranges:
        return mask_hsv_single(hsv, ranges["low"], ranges["high"], ek, dk)
    mask = None
    for r in (ranges if isinstance(ranges, list) else []):
        if "low" in r and "high" in r:
            m = mask_hsv_single(hsv, r["low"], r["high"], ek, dk)
            mask = m if mask is None else cv.bitwise_or(mask, m)
    if mask is None: mask = np.zeros(hsv.shape[:2], dtype=np.uint8)
    return mask

# =================== MAIN ===================
def main():
    cfg, cfg_path = load_latest_yaml()
    print("Loaded vision config:", cfg_path)

    # ---- Serial (robust) ----
    ser = None
    device = TUNE["ROBOT_PORT"]
    baud = TUNE["ROBOT_BAUD"]

    last_tlm_t = 0.0
    last_pong_t = 0.0
    last_ping_t = 0.0
    last_reset_t = -1e9

    rx_buf = b""
    tlm_re = re.compile(r"^TLM,.*yaw=([\-0-9\.]+),state=([0-9]),steer=([\-0-9\.]+),speed=([0-9]+),dF=([\-0-9]+),dL=([\-0-9]+),dR=([\-0-9]+)")

    def open_serial():
        nonlocal ser
        if serial is None:
            print("PySerial not available."); return
        try:
            ser = serial.Serial(device, baudrate=baud, timeout=0.01, write_timeout=0.2, dsrdtr=False)
            time.sleep(0.35)
            ser.reset_input_buffer(); ser.reset_output_buffer()
            print("Serial OK on", device)
        except Exception as e:
            print("WARNING: serial not open ->", e); ser = None

    def safe_write(line_bytes):
        nonlocal ser
        if serial is None: return False
        if ser is None:
            open_serial()
            if ser is None: return False
        try:
            ser.write(line_bytes); return True
        except Exception as e:
            print("Serial write error:", e)
            try: ser.close()
            except Exception: pass
            ser=None
            open_serial()
            if ser:
                try: ser.write(line_bytes); return True
                except Exception as e2: print("Write retry failed:", e2)
        return False

    def reset_arduino(method="AUTO"):
        nonlocal ser, last_reset_t
        now = time.time()
        if now - last_reset_t < TUNE["RESET_BACKOFF_SEC"]: return False
        last_reset_t = now
        meth = (method or "AUTO").upper()
        port = device
        def do_touch1200():
            try:
                print("[RESET] 1200-bps touch...")
                tmp = serial.Serial(port, 1200, timeout=0.05)
                time.sleep(0.05); tmp.setDTR(False); tmp.flush(); tmp.close()
                time.sleep(TUNE["ARD_RESET_TOUCH_DELAY_S"])
                return True
            except Exception as e:
                print("[RESET] 1200-bps touch failed:", e); return False
        def do_dtr():
            try:
                print("[RESET] DTR pulse...")
                s = serial.Serial(
